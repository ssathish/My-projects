import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
//import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;

/**
 * @author Sathish Srinivasan
 *
 */
public class PropositionalLogic 
{
	/**
	 * Main program starts
	 */
	public static void main(String[] args) 
	{
		String path=new String("src/");
		LinkedList<String> KB=new LinkedList<String>();
		LinkedList<String> alpha=new LinkedList<String>();		
		String kb_str1,kb_str2,kb_str3,alpha_str1,alpha_str2,alpha_str3;
		String inp1_filename,inp2_filename,out_filename;
		StringBuffer statement=new StringBuffer();
		StringBuffer result= new StringBuffer();
		BufferedReader br;
		boolean valid=true;

		try
		{
			if(args[0].equals("-task1"))
			{
				inp1_filename=new String(path+args[1]);
				br=new BufferedReader(new FileReader(inp1_filename));
				while((kb_str1=br.readLine())!=null)
				{
					kb_str2=kb_str1.replaceAll("\\(","\\( ");
					kb_str3=kb_str2.replaceAll("\\)"," \\)");
					convert_to_CNF_part1(kb_str3,KB);
				}	
				br.close();
				convert_to_CNF_part2(KB);
				for(int i=0;i<KB.size();i++)
					result.append(KB.get(i)+"\n");
				out_filename=new String(path+args[2]);
				write_it_to_file(result,out_filename);
			}

			else if(args[0].equals("-task2"))
			{
				inp1_filename=new String(path+args[1]);
				br=new BufferedReader(new FileReader(inp1_filename));
				while((kb_str1=br.readLine())!=null)
				{
					kb_str2=kb_str1.replaceAll("\\(","\\( ");
					kb_str3=kb_str2.replaceAll("\\)"," \\)");
					convert_to_CNF_part1(kb_str3,KB);
				}	
				br.close();
				convert_to_CNF_part2(KB);
				/*System.out.println("converted to CNF");
				for(int i=0;i<KB.size();i++)
					System.out.println("after cnf:"+KB.get(i));*/
				for(int i=0;i<KB.size();i++)
				{
					valid=check_if_valid(KB.get(i));
					if(!valid)
						break;
				}
				if(!valid)
				{
					System.out.println("entering:");
					result.append(pl_resolution(KB,alpha));
					if(result.toString().equals("Entailed"))
					{
						result.delete(0,result.length());
						result.append("Unsatisfiable\n");
					}
					else if(result.toString().equals("Not entailed"))
					{
						result.delete(0,result.length());
						result.append("Satisfiable\n");
					}
				}
				else
					result.append("Valid\n");
				out_filename=new String(path+args[2]);
				write_it_to_file(result,out_filename);
			}

			else if(args[0].equals("-task3"))
			{
				inp1_filename=new String(path+args[1]);				
				br=new BufferedReader(new FileReader(inp1_filename));	
				while((kb_str1=br.readLine())!=null)
				{
					kb_str2=kb_str1.replaceAll("\\(","\\( ");
					kb_str3=kb_str2.replaceAll("\\)"," \\)");
					convert_to_CNF_part1(kb_str3,KB);
				}	
				br.close();
				convert_to_CNF_part2(KB);

				inp2_filename=new String(path+args[2]);
				br=new BufferedReader(new FileReader(inp2_filename));
				result.delete(0,result.length());
				while((alpha_str1=br.readLine())!=null)
				{
					alpha.clear();
					alpha_str2=alpha_str1.replaceAll("\\(","\\( ");
					alpha_str3=alpha_str2.replaceAll("\\)"," \\)");
					statement.delete(0, statement.length());
					statement.append("( NOT "+alpha_str3+" )");
					convert_to_CNF_part1(statement.toString(),alpha);
					convert_to_CNF_part2(alpha);
					result.append(pl_resolution(KB,alpha)+"\n");
				}
				out_filename=new String(path+args[3]);
				write_it_to_file(result,out_filename);
			}
		}
		catch (Exception ex)
		{
			ex.printStackTrace();
		}

	}


	public static boolean check_if_valid(String clause) 
	{
		boolean valid=false;
		StringBuffer c1=new StringBuffer(clause);
		StringBuffer lit1=new StringBuffer();
		StringBuffer lit2=new StringBuffer();
		LinkedList<String> c1_literals=new LinkedList<String>();

		get_literals(c1, c1_literals);
		for(int i=0;i<c1_literals.size()-1;i++)
		{
			lit1.delete(0, lit1.length());
			lit1.append(c1_literals.get(i));
			for(int j=i+1;j<c1_literals.size();j++)
			{
				lit2.delete(0, lit2.length());
				lit2.append(c1_literals.get(j));
				valid=check_if_complmentary_literals(lit1, lit2);
				if(valid)
					break;
			}
			if(valid)
				break;
		}
		return valid;
	}


	public static void write_it_to_file(StringBuffer result,String out_filename)
	{
		try
		{
			File file = new File(out_filename);
			if (!file.exists()) 
				file.createNewFile();

			FileWriter fw = new FileWriter(file.getAbsoluteFile());
			BufferedWriter bw = new BufferedWriter(fw);
			bw.write(result.toString());
			bw.close();
		}
		catch (Exception ex)
		{
			ex.printStackTrace();
		}
		return;
	}

	public static StringBuffer pl_resolution(LinkedList<String> KB,LinkedList<String> alpha) 
	{
		StringBuffer resolvents=new StringBuffer();
		StringBuffer result=new StringBuffer();
		StringBuffer c1=new StringBuffer();
		StringBuffer c2=new StringBuffer();
		//StringBuffer eg1=new StringBuffer();
		//StringBuffer eg2=new StringBuffer();

		LinkedList<String> gen=new LinkedList<String>();
		LinkedList<String> clauses= new LinkedList<String>();
		//LinkedList<String> new_clauses= new LinkedList<String>();
		LinkedList<String> recent=new LinkedList<String>();
		/*LinkedList<String> c1_literals=new LinkedList<String>();
	LinkedList<String> c2_literals=new LinkedList<String>();
	LinkedList<String> combined_literals=new LinkedList<String>();
		 */
		boolean do_loop=false,added=false,contains=true;
		long startTime=0,endTime=0,totalTime=0;

		/*eg1.append("( OR ( NOT tv ) ( party ) )");
	eg2.append("( OR ( NOT tv ) ( NOT party ) )");
	if(!has_comp_literals(eg1,eg2))
		System.out.println("success");*/

		for(int i=0;i<KB.size();i++)
		{
			clauses.add(KB.get(i));
			//new_clauses.add(KB.get(i));
			gen.add(KB.get(i));
		}
		for(int i=0;i<alpha.size();i++)
		{
			clauses.add(alpha.get(i));
			//new_clauses.add(alpha.get(i));
			gen.add(alpha.get(i));
		}
		//Collections.sort(clauses);
		//Collections.sort(gen);
		startTime   = System.currentTimeMillis();

		while(true)
		{
			do_loop=false;
			recent.clear();
			//System.out.println("hello");
			for(int i=0;i<gen.size();i++)
			{
				c1.delete(0, c1.length());
				c1.append(gen.get(i).trim());
				//System.out.println("hello i");
				for(int j=0;j<clauses.size();j++)
				{
					contains=true;
					c2.delete(0, c2.length());
					c2.append(clauses.get(j).trim());
					//System.out.println("hello j");
					contains=has_comp_literals(c1,c2);
					if(contains)
					{
						//System.out.println("resolve "+c1+" with "+c2);
						added=false;
						resolvents.delete(0, resolvents.length());
						resolvents.append(resolve(c1,c2));
						if((resolvents.toString().equals("BLANK"))||(resolvents.toString().equals(" "))||(resolvents.toString().equals("")))
						{
							//System.out.println("entailed string:");
							result.delete(0,result.length());
							result.append("Entailed");
							clauses.clear();
							recent.clear();
							return result;
						}
						remove_unwanted_paranthesis(resolvents);
						remove_unwanted_brackets(resolvents);
						/*tmp.delete(0, tmp.length());
					tmp.append(remove_unwanted_paranthesis(resolvents));
					resolvents.delete(0, resolvents.length());
					resolvents.append(tmp);

					tmp.delete(0, tmp.length());
					tmp.append(remove_unwanted_paranthesis(resolvents));
					remove_unwanted_brackets(resolvents);
					resolvents.append(tmp);*/

						for(int p=0;p<recent.size();p++)
						{
							//System.out.println("resolve:"+resolvents);
							if(recent.get(p).equals(resolvents.toString().trim()))
							{
								added=true;
								break;
							}
							else
								added=false;
						}
						//System.out.println("resolvents:"+resolvents+"\n");
						if(!added)
						{
							//System.out.println("recent:"+resolvents);
							//System.out.println("added");
							if(!has_comp_literals(resolvents, resolvents))
								recent.add(resolvents.toString().trim());
						}
					}
				}
			}
			//System.out.println("recent count1:"+recent.size());
			//is_it_always_true(recent);
			//System.out.println("recent count2:"+recent.size());

			gen.clear();
			int tmp=clauses.size();
			System.out.println("clause count:"+clauses.size());
			for(int p=0;p<recent.size();p++)
			{
				if(!is_recent_is_subset_of_clauses(recent.get(p),clauses))
				{
					do_loop=true;
					//System.out.println("newly added:"+recent.get(p));
					clauses.add(recent.get(p));
					//recent.remove(p);
					gen.add(recent.get(p));
				}
			}
			//Collections.sort(clauses);
			//Collections.sort(gen);
			tmp=clauses.size()-tmp;
			System.out.println("clauses diff count1:"+tmp);
			if(!do_loop)
			{
				result.delete(0,result.length());
				result.append("Not entailed");
				clauses.clear();
				recent.clear();
				break;
			}
			else
				System.out.println("next do count:"+clauses.size());
			endTime   = System.currentTimeMillis();
			totalTime = endTime - startTime;
			/*if(totalTime>300000)
		{
			result.delete(0, result.length());
			result.append("Not terminated");
			break;
		}*/
		}
		//clauses.clear();
		return result;
	}

	/*private static boolean contains_comp_literals(LinkedList<String> literals, String str) 
	{
		boolean contains=false;
		StringBuffer to_match=new StringBuffer(str);
		if (to_match.toString().indexOf("NOT")==-1)
		{
			to_match.insert(0, "NOT ");
		}
		for(int i=0;i<literals.size();i++)
		{
			if(literals.get(i).equals(to_match.toString()))
			{
				contains=true;
				break;
			}
		}
		return contains;
	}*/

	private static boolean has_comp_literals(StringBuffer c1, StringBuffer c2) 
	{
		boolean contains=false,comp=false;
		LinkedList<String> c1_literals=new LinkedList<String>();
		LinkedList<String> c2_literals=new LinkedList<String>();
		StringBuffer lit1=new StringBuffer();
		StringBuffer lit2=new StringBuffer();

		get_literals(c1, c1_literals);
		get_literals(c2, c2_literals);
		for(int i=0;i<c1_literals.size();i++)
		{
			//System.out.println("i:"+i+" c1: "+c1_literals.get(i));
			lit1.delete(0, lit1.length());
			lit1.append(c1_literals.get(i));
			for(int j=0;j<c2_literals.size();j++)
			{
				//System.out.println("j:"+j+" c2: "+c2_literals.get(j));
				lit2.delete(0, lit2.length());
				lit2.append(c2_literals.get(j));
				comp=check_if_complmentary_literals(lit1, lit2);
				if(comp)
				{
					contains=true;
					break;
				}
			}
			if(contains)
				break;
		}
		c1_literals.clear();
		c2_literals.clear();
		return contains;
	}

	public static void is_it_always_true(LinkedList<String> storage) 
	{
		StringBuffer statement=new StringBuffer();
		StringBuffer result=new StringBuffer();

		for(int i=0;i<storage.size();)
		{
			statement.delete(0, statement.length());
			statement.append(storage.get(i));
			result.delete(0,result.length());
			//statement.append(storage.get(i));
			//statement=new StringBuffer(evaluate_if_always_true(statement));
			result.append(evaluate_if_always_true(statement));
			if(result.toString().equals("TRUE"))
			{
				//System.out.println("storage removed:"+storage.get(i));
				storage.remove(i);
			}
			else
				i++;
		}
		return;
	}

	public static StringBuffer evaluate_if_always_true(StringBuffer statement) 
	{
		LinkedList<String> literals=new LinkedList<String>();
		StringBuffer c1=new StringBuffer();
		StringBuffer c2=new StringBuffer();
		StringBuffer result=new StringBuffer(statement);

		get_literals(statement, literals);
		for(int i=0;i<literals.size()-1;i++)
		{
			c1.delete(0, c1.length());
			c1.append(literals.get(i));
			for(int j=i+1;j<literals.size();j++)
			{
				c2.delete(0, c2.length());
				c2.append(literals.get(j));
				if(check_if_complmentary_literals(c1, c2))
				{
					result.delete(0, result.length());
					result.append("TRUE");
					return result;
				}
			}
		}
		literals.clear();
		return result;
	}

	private static boolean is_recent_is_subset_of_clauses(String str,LinkedList<String> clauses) 
	{
		boolean subset=false;
		StringBuffer recent=new StringBuffer(str);
		for(int i=0;i<clauses.size();i++)
		{
			if(clauses.get(i).equals(recent.toString().trim()))
			{
				subset=true;
				break;
			}
			else
				subset=false;

		}
		return subset;
	}

	private static void remove_unwanted_brackets(StringBuffer statement) 
	{
		LinkedList<String> tokenValue=new LinkedList<String>();
		LinkedList<String> tokenType=new LinkedList<String>();
		//StringBuffer statement=new StringBuffer();

		//	statement=new StringBuffer(storage.get(i));
		tokenValue.clear();tokenType.clear();
		split_into_tokens(tokenValue,statement);
		classify_tokens_based_on_type(tokenValue, tokenType);

		for(int j=0;j<tokenType.size()-3;j++)
		{
			//tokenType.get(j).
			//if(tokenType.contains("( LIT )")
			if((tokenType.get(j).equals("("))&&(tokenType.get(j+1).equals("LIT"))&&(tokenType.get(j+2).equals(")")))
			{
				//System.out.println("j:"+tokenValue.get(j)+" j+1:"+tokenValue.get(j+1)+" j+2:"+tokenValue.get(j+2));
				tokenValue.remove(j);
				tokenType.remove(j);
				//System.out.println("j:"+tokenValue.get(j)+" j+1:"+tokenValue.get(j+1)+" j+2:"+tokenValue.get(j+2));
				tokenValue.remove(j+1);
				tokenType.remove(j+1);
			}
		}
		combine_tokens(tokenValue, statement);
		//storage.remove(i);
		//storage.add(i,statement.toString());
		//}
		tokenValue.clear();
		tokenType.clear();
		return;

	}

	/*private static StringBuffer resolve(LinkedList<String> literals, String to_resolve) 
	{
		StringBuffer result=new StringBuffer();
		StringBuffer lit1=new StringBuffer(to_resolve.trim());
		LinkedList<String> tmp_literals= new LinkedList<String>();
		LinkedList<String> combined=new LinkedList<String>();
		LinkedList<String> finalList=new LinkedList<String>();


		boolean resolve=false,same=false,comp_flag=false;	

		int i=0;

		for(i=0;i<literals.size();i++)
		{
			tmp_literals.add(literals.get(i).trim());
			//System.out.println("tmp:"+tmp_literals.get(i));
		}

		for(i=0;i<tmp_literals.size();)
		{
			StringBuffer lit2=new StringBuffer(tmp_literals.get(i).toString().trim());
			resolve=check_if_complmentary_literals(lit1,lit2);
			if(resolve)
			{
				comp_flag=true;
				tmp_literals.remove(i);	
				//break;
			}
			else
			{
				same=check_if_same_literals(lit1,lit2);
				if(same)
				{
					tmp_literals.remove(i);
				}
				else
					i++;
			}
		}
		if(!comp_flag)
			tmp_literals.add(to_resolve.toString().trim());
		String[] test=new String[tmp_literals.size()];
		//if(tmp_literals.size()>0)
		//{
		tmp_literals.toArray(test);		
		Arrays.sort(test);
		tmp_literals.clear();
		//}

		for(i=0;i<test.length;i++)
		{
			//System.out.println("test:"+test[i]);
			combined.add("( "+test[i]+" )");
		}
		//tmp_literals.clear();

		if(combined.size()>0)
		{
			for(i=0;i<combined.size()-1;i++)
			{
				result.append("( OR "+combined.get(i)+" ");
			}
			result.append(" "+combined.get(i));
			for(i=0;i<combined.size()-1;i++)
				result.append(" )");
			//split_into_tokens(finalList, result);
			//combine_tokens(finalList, result);
		}
		else
			result.append("BLANK");
		//combine_tokens(combined, result);
		//System.out.println("final:"+result);
		//System.out.println("exit");
		return result;
	}*/

	private static StringBuffer resolve(StringBuffer str1, StringBuffer str2) 
	{
		StringBuffer result=new StringBuffer();
		StringBuffer clause1=new StringBuffer(str1);
		StringBuffer clause2=new StringBuffer(str2);
		StringBuffer c1=new StringBuffer();
		StringBuffer c2=new StringBuffer();

		LinkedList<String> c1_literals = new LinkedList<String>();
		LinkedList<String> c2_literals = new LinkedList<String>();
		LinkedList<String> tmp=new LinkedList<String>();
		LinkedList<String> combined=new LinkedList<String>();
		//String[] test=new String[1000];
		boolean resolve=false,same=false;

		get_literals(clause1,c1_literals);
		get_literals(clause2,c2_literals);	
		for(int i=0;i<c1_literals.size();i++)
		{
			c1.delete(0, c1.length());
			c1.append(c1_literals.get(i));
			resolve=false;
			for(int j=0;j<c2_literals.size();)
			{
				c2.delete(0, c2.length());
				c2.append(c2_literals.get(j));
				resolve=check_if_complmentary_literals(c1,c2);
				//System.out.println("returned value:"+resolve);
				if(resolve)
				{
					c1_literals.remove(i);
					c2_literals.remove(j);
					break;
				}
				else
				{
					same=check_if_same_literals(c1,c2);
					if(same)
						c2_literals.remove(j);
					else
						j++;
				}
			}
			if(resolve)
				break;
		}

		/*for(int i=0;i<c1_literals.size();i++)
		{
			System.out.println("c1 value i:"+i+" literal:"+c1_literals.get(i));
		}
		for(int i=0;i<c2_literals.size();i++)
		{
			System.out.println("c2 value i:"+i+" literal:"+c2_literals.get(i));
		}

		//System.out.println("hello");*/
		for(int i=0;i<c1_literals.size();i++)
		{
			tmp.add(c1_literals.get(i).toString().trim());
		}
		c1_literals.clear();
		//System.out.println("hello");
		for(int i=0;i<c2_literals.size();i++)
		{
			tmp.add(c2_literals.get(i).toString().trim());
		}

		c2_literals.clear();
		//System.out.println("hello");
		//combined.toArray(test);
		//test.length=combined.size();
		Collections.sort(tmp);
		//combined.clear();

		for(int i=0;i<tmp.size()-1;i++)
		{

			if(tmp.get(i).equals(tmp.get(i+1).toString()))
			{
				tmp.remove(i);
				i--;
			}
			else
				combined.add("( "+tmp.get(i)+" )");
		}
		if(tmp.size()>0)
			combined.add("( "+tmp.get(tmp.size()-1)+" )");
		tmp.clear();
		if(combined.size()>0)
		{
			for(int i=0;i<combined.size()-1;i++)
			{
				result.append("( OR "+combined.get(i)+" ");
			}
			result.append(" "+combined.get(combined.size()-1));
			for(int i=0;i<combined.size()-1;i++)
				result.append(" )");
		}
		else
			result.append("BLANK");
		//System.out.println("final:"+result);
		c1_literals.clear();
		c2_literals.clear();
		combined.clear();
		return result;
	}

	private static boolean check_if_same_literals(StringBuffer c1, StringBuffer c2) 
	{
		StringBuffer tmp1=new StringBuffer(c1);
		StringBuffer tmp2=new StringBuffer(c2);
		boolean same=false;

		//System.out.println("in same lit c1:"+ c1);
		//System.out.println("in same lit c2:"+ c2);
		//tmp1.insert(0, "NOT ");
		//System.out.println("tmp1:"+tmp1);
		//System.out.println("tmp2:"+tmp2);
		if(tmp1.toString().equals(tmp2.toString()))
			same=true;

		return same;
	}

	private static boolean check_if_complmentary_literals(StringBuffer c1, StringBuffer c2) 
	{
		StringBuffer tmp1=new StringBuffer(c1);
		StringBuffer tmp2=new StringBuffer(c2);
		boolean negation=false;

		//System.out.println("in comp lit c1:"+ c1);
		//System.out.println("in comp lit c2:"+ c2);
		tmp1.insert(0, "NOT ");
		//System.out.println("tmp1:"+tmp1);
		//System.out.println("tmp2:"+tmp2);
		if(tmp1.toString().equals(tmp2.toString()))
			negation=true;
		else
		{
			tmp1.delete(0, tmp1.length());
			tmp1.append(c1);
			tmp2.insert(0, "NOT ");
			if(tmp2.toString().equals(tmp1.toString()))
				negation=true;
		}
		return negation;
	}

	private static void get_literals(StringBuffer clause,LinkedList<String> clause_literals)
	{
		StringBuffer statement=new StringBuffer();
		StringBuffer operand= new StringBuffer();

		split_into_tokens(clause_literals, clause);
		for(int i=0;i<clause_literals.size();)
		{
			if((clause_literals.get(i).equals("("))||(clause_literals.get(i).equals("OR"))||(clause_literals.get(i).equals(")"))||(clause_literals.get(i).matches("[ \\t\\n\\r]+")))
				clause_literals.remove(i);
			else
				i++;
		}
		if(clause_literals.size()>0)
		{
			for(int i=0;i<clause_literals.size();i++)
			{
				if(clause_literals.get(i).equals("NOT"))
				{
					operand.delete(0, operand.length());
					operand.append("NOT "+clause_literals.get(i+1));
					clause_literals.remove(i);
					clause_literals.remove(i);
					clause_literals.add(i,operand.toString());
				}
			}
			combine_tokens(clause_literals, statement);
		}
		else
		{
			statement.delete(0, statement.length());
			statement.append("BLANK");
		}

		//System.out.println("combined literals:"+statement);
		return;
	}

	public static void convert_to_CNF_part1(String line,LinkedList<String> storage)
	{
		StringBuffer statement=new StringBuffer(line);
		StringBuffer result=new StringBuffer();
		/*statement=new StringBuffer(remove_unwanted_paranthesis(statement));
		statement=new StringBuffer(remove_bi_conditional(statement));
		statement=new StringBuffer(remove_unwanted_paranthesis(statement));
		statement=new StringBuffer(remove_single_conditional(statement));
		statement=new StringBuffer(remove_unwanted_paranthesis(statement));
		statement=new StringBuffer(expand_NOT(statement));
		statement=new StringBuffer(remove_unwanted_paranthesis(statement));*/
		result.delete(0, result.length());
		result.append(remove_unwanted_paranthesis(statement));
		statement.delete(0, statement.length());
		statement.append(result);
		result.delete(0, result.length());

		result.append(remove_bi_conditional(statement));
		statement.delete(0, statement.length());
		statement.append(result);
		result.delete(0, result.length());

		result.append(remove_unwanted_paranthesis(statement));
		statement.delete(0, statement.length());
		statement.append(result);
		result.delete(0, result.length());

		result.append(remove_single_conditional(statement));
		statement.delete(0, statement.length());
		statement.append(result);
		result.delete(0, result.length());

		result.append(remove_unwanted_paranthesis(statement));
		statement.delete(0, statement.length());
		statement.append(result);
		result.delete(0, result.length());

		result.append(expand_NOT(statement));
		statement.delete(0, statement.length());
		statement.append(result);
		result.delete(0, result.length());

		result.append(remove_unwanted_paranthesis(statement));
		statement.delete(0, statement.length());
		statement.append(result);
		result.delete(0, result.length());

		if(!storage.contains(statement.toString()))
			storage.add(statement.toString());
		return ;
	}

	public static void convert_to_CNF_part2(LinkedList<String> storage)
	{
		StringBuffer statement=new StringBuffer();
		StringBuffer result=new StringBuffer();
		LinkedList<String> tokens=new LinkedList<String>();		
		//boolean result=false;

		divide_into_clauses(storage);	
		for(int i=0;i<storage.size();i++)
		{
			statement.delete(0, statement.length());
			statement.append(storage.get(i));
			split_into_tokens(tokens,statement);
			while(tokens.contains("AND"))
			{
				result.delete(0, result.length());
				result.append(distribute_OR(statement));
				statement.delete(0, statement.length());
				statement.append(result);

				remove_unwanted_paranthesis(statement);
				storage.remove(i);
				if(!storage.contains(statement.toString()))
					storage.add(i,statement.toString());
				/*else
					System.out.println("removed");*/
				divide_into_clauses(storage);
				statement.delete(0, statement.length());
				statement.append(storage.get(i));
				tokens.clear();
				split_into_tokens(tokens,statement);
			}
		}
		remove_unwanted_braces(storage);
		add_braces_at_start(storage);
		remove_if_two_operands_are_same(storage);
		remove_always_true(storage);

		tokens.clear();
		return;
	}


	public static void remove_if_two_operands_are_same(LinkedList<String> storage) 
	{
		StringBuffer statement=new StringBuffer();
		StringBuffer result=new StringBuffer();

		for(int i=0;i<storage.size();i++)
		{
			statement.delete(0, statement.length());
			statement.append(storage.get(i));

			result.delete(0, result.length());
			result.append(evaluate_stmt_if_same(statement));
			statement.delete(0, statement.length());
			statement.append(result);

			storage.remove(i);
			if (!storage.contains(statement.toString()))
				storage.add(i, statement.toString());
			/*if(statement.toString().equals("SAME"))
			{
				//System.out.println("storage removed:"+storage.get(i));
				storage.remove(i);
			}
			else
				i++;*/
		}
		return;
	}

	public static StringBuffer evaluate_stmt_if_same(StringBuffer statement) 
	{
		StringBuffer result=new StringBuffer();
		StringBuffer op1=new StringBuffer();
		StringBuffer op2=new StringBuffer();

		StringBuffer new_op1=new StringBuffer();
		StringBuffer new_op2=new StringBuffer();

		LinkedList<String> tokens=new LinkedList<String>();
		LinkedList<String> op1_tokens=new LinkedList<String>();
		//LinkedList<String> op1_tokenType=new LinkedList<String>();
		LinkedList<String> op2_tokens=new LinkedList<String>();
		//LinkedList<String> op2_tokenType=new LinkedList<String>();
		int opr_index=0,op1_end_index=0;//op2_end_index=0;
		//boolean flag= true,distributed=false;

		//System.out.println("begin:"+statement);
		split_into_tokens(tokens, statement);
		if(tokens.contains("OR"))
		{
			opr_index=tokens.indexOf("OR");
			op1_end_index=get_operand(tokens, opr_index+1, op1);
			get_operand(tokens, op1_end_index+1, op2);

			//System.out.println("op1:"+op1);
			//System.out.println("op2:"+op2);
			split_into_tokens(op1_tokens, op1);
			if(op1_tokens.contains("OR"))
			{
				new_op1.delete(0, new_op1.length());
				new_op1.append(evaluate_stmt_if_same(op1));
				op1.delete(0, op1.length());
				op1.append(new_op1);
				//System.out.println("op1 after eval:"+op1);
			}
			/*	else
			{
				distributed=check_if_NOT_already_distributed(op1);
				op1_tokens.add(0,"(");
				op1_tokens.add(1,"NOT");
				op1_tokens.add(")");
				classify_tokens_based_on_type(op1_tokens, op1_tokenType);				
				if(!distributed)
				{
					distribute_NOT(op1_tokens, op1_tokenType, 1);
				}				
				combine_tokens(op1_tokens, op1);
				//System.out.println("op1 after not distribute:"+op1);
			}*/
			split_into_tokens(op2_tokens, op2);
			if(op2_tokens.contains("OR"))
			{
				new_op2.delete(0, new_op2.length());
				new_op2.append(evaluate_stmt_if_same(op2));
				op2.delete(0, op2.length());
				op2.append(new_op2);
				//System.out.println("op2 after eval:"+op2);
			}
			/*else
			{
				op2_tokens.add(0,"(");
				op2_tokens.add(1,"NOT");
				op2_tokens.add(")");
				classify_tokens_based_on_type(op2_tokens, op2_tokenType);
				distribute_NOT(op2_tokens, op2_tokenType, 1);
				combine_tokens(op2_tokens, op2);
			}
			if((op1.toString().equals("TRUE"))||(op2.toString().equals("TRUE")))
			{
				statement=new StringBuffer("TRUE");
				flag=true;
			}
			else
				flag=false;
			if(!flag)
			{*/
			StringBuffer old_op1=new StringBuffer(op1);
			StringBuffer old_op2=new StringBuffer(op2);

			new_op1.delete(0, new_op1.length());
			new_op1.append(remove_all_braces(op1));
			op1.delete(0, op1.length());
			op1.append(new_op1);

			new_op1.delete(0, new_op1.length());
			new_op2.append(remove_all_braces(op2));
			op2.delete(0, op2.length());
			op2.append(new_op2);

			//System.out.println("op1:"+op1+" op2:"+op2);
			if(op1.toString().equals(op2.toString()))
			{
				statement.delete(0, statement.length());
				statement.append(old_op1);
			}
			else
			{
				statement.delete(0, statement.length());
				statement.append("( OR "+old_op1+" "+old_op2+" )");
			}
			//}
		}
		//System.out.println("end:"+statement);
		result.append(statement);

		tokens.clear();
		op1_tokens.clear();
		op2_tokens.clear();
		return result;
	}

	public static void remove_always_true(LinkedList<String> storage) 
	{
		StringBuffer statement=new StringBuffer();
		StringBuffer result=new StringBuffer();

		for(int i=0;i<storage.size();)
		{
			statement.delete(0,statement.length());
			statement.append(storage.get(i));

			result.delete(0, result.length());
			result.append(evaluate_stmt_if_true(statement));
			statement.delete(0, statement.length());
			statement.append(result);

			if(statement.toString().equals("TRUE"))
			{
				//System.out.println("storage removed:"+storage.get(i));
				storage.remove(i);
			}
			else
				i++;
		}
		return;
	}

	public static StringBuffer evaluate_stmt_if_true(StringBuffer statement) 
	{
		StringBuffer result=new StringBuffer();
		StringBuffer op1=new StringBuffer();
		StringBuffer op2=new StringBuffer();
		StringBuffer new_op1=new StringBuffer();
		StringBuffer new_op2=new StringBuffer();

		LinkedList<String> tokens=new LinkedList<String>();
		LinkedList<String> op1_tokens=new LinkedList<String>();
		LinkedList<String> op1_tokenType=new LinkedList<String>();
		LinkedList<String> op2_tokens=new LinkedList<String>();
		//LinkedList<String> op2_tokenType=new LinkedList<String>();
		int opr_index=0,op1_end_index=0;//op2_end_index=0;
		boolean flag= true,distributed=false;

		//System.out.println("begin:"+statement);
		split_into_tokens(tokens, statement);
		if(tokens.contains("OR"))
		{
			opr_index=tokens.indexOf("OR");
			op1_end_index=get_operand(tokens, opr_index+1, op1);
			get_operand(tokens, op1_end_index+1, op2);

			//System.out.println("op1:"+op1);
			//System.out.println("op2:"+op2);
			split_into_tokens(op1_tokens, op1);
			if(op1_tokens.contains("OR"))
			{
				new_op1.delete(0, new_op1.length());
				new_op1.append(evaluate_stmt_if_true(op1));
				op1.delete(0, op1.length());
				op1.append(new_op1);
				//System.out.println("op1 after eval:"+op1);
			}
			else
			{
				distributed=check_if_NOT_already_distributed(op1);
				op1_tokens.add(0,"(");
				op1_tokens.add(1,"NOT");
				op1_tokens.add(")");
				classify_tokens_based_on_type(op1_tokens, op1_tokenType);				
				if(!distributed)
				{
					distribute_NOT(op1_tokens, op1_tokenType, 1);
				}				
				combine_tokens(op1_tokens, op1);
				//System.out.println("op1 after not distribute:"+op1);
			}
			split_into_tokens(op2_tokens, op2);
			if(op2_tokens.contains("OR"))
			{
				new_op2.delete(0, new_op2.length());
				new_op2.append(evaluate_stmt_if_true(op2));
				op2.delete(0, op2.length());
				op2.append(new_op2);
				//System.out.println("op2 after eval:"+op2);
			}
			/*else
			{
				op2_tokens.add(0,"(");
				op2_tokens.add(1,"NOT");
				op2_tokens.add(")");
				classify_tokens_based_on_type(op2_tokens, op2_tokenType);
				distribute_NOT(op2_tokens, op2_tokenType, 1);
				combine_tokens(op2_tokens, op2);
			}*/
			if((op1.toString().equals("TRUE"))||(op2.toString().equals("TRUE")))
			{
				statement.delete(0, statement.length());
				statement.append("TRUE");
				flag=true;
			}
			else
				flag=false;
			if(!flag)
			{
				new_op1.delete(0, new_op1.length());
				new_op1.append(remove_all_braces(op1));
				op1.delete(0, op1.length());
				op1.append(new_op1);

				new_op2.delete(0, new_op2.length());
				new_op2.append(remove_all_braces(op2));
				op2.delete(0, op2.length());
				op2.append(new_op2);

				if(op1.toString().equals(op2.toString()))
				{
					statement.delete(0, statement.length());
					statement.append("TRUE");
				}
			}
		}
		//System.out.println("end:"+statement);
		result.append(statement);

		tokens.clear();
		op1_tokens.clear();
		op1_tokenType.clear();
		op2_tokens.clear();
		return result;

	}

	public static StringBuffer remove_all_braces(StringBuffer line) 
	{
		LinkedList<String> tokens=new LinkedList<String>();

		split_into_tokens(tokens, line);
		for(int i=0;i<tokens.size();)
		{
			if((tokens.get(i).equals("("))||(tokens.get(i).equals(")")))
				tokens.remove(i);
			else
				i++;
		}
		combine_tokens(tokens, line);
		tokens.clear();
		return line;
	}

	public static void add_braces_at_start(LinkedList<String> storage) 
	{
		LinkedList<String> tokenValue=new LinkedList<String>();
		StringBuffer statement=new StringBuffer();

		for(int i=0;i<storage.size();i++)
		{
			statement.delete(0, statement.length());
			statement.append(storage.get(i));
			tokenValue.clear();
			split_into_tokens(tokenValue,statement);
			if(!tokenValue.get(0).equals("("))
			{
				tokenValue.add(0,"(");
				tokenValue.add(")");
			}
			combine_tokens(tokenValue, statement);
			storage.remove(i);
			storage.add(i,statement.toString());
		}
		tokenValue.clear();
		return;
	}

	public static void remove_unwanted_braces(LinkedList<String> storage) 
	{
		LinkedList<String> tokenValue=new LinkedList<String>();
		LinkedList<String> tokenType=new LinkedList<String>();
		StringBuffer statement=new StringBuffer();

		for(int i=0;i<storage.size();i++)
		{
			statement.delete(0, statement.length());
			statement.append(storage.get(i));
			tokenValue.clear();tokenType.clear();
			split_into_tokens(tokenValue,statement);
			classify_tokens_based_on_type(tokenValue, tokenType);

			for(int j=0;j<tokenType.size()-3;j++)
			{
				//tokenType.get(j).
				//if(tokenType.contains("( LIT )")
				if((tokenType.get(j).equals("("))&&(tokenType.get(j+1).equals("LIT"))&&(tokenType.get(j+2).equals(")")))
				{
					//System.out.println("j:"+tokenValue.get(j)+" j+1:"+tokenValue.get(j+1)+" j+2:"+tokenValue.get(j+2));
					tokenValue.remove(j);
					tokenType.remove(j);
					//System.out.println("j:"+tokenValue.get(j)+" j+1:"+tokenValue.get(j+1)+" j+2:"+tokenValue.get(j+2));
					tokenValue.remove(j+1);
					tokenType.remove(j+1);
				}
			}
			combine_tokens(tokenValue, statement);
			storage.remove(i);
			storage.add(i,statement.toString());
		}
		tokenValue.clear();
		tokenType.clear();
		return;
	}

	/*public static boolean check_if_statement_is_always_true(StringBuffer statement) 
	{
		boolean result=false;
		LinkedList<String> tokens=new LinkedList<String>();

		split_into_tokens(tokens, statement);
		if(tokens.contains("OR"))
		{

		}
		return result;
	}*/

	public static StringBuffer remove_single_conditional(StringBuffer statement) 
	{
		LinkedList<String> tokenValue=new LinkedList<String>();
		LinkedList<String> tokenType=new LinkedList<String>();

		split_into_tokens(tokenValue,statement);
		//classify_tokens_based_on_type(tokenValue,tokenType);
		while(tokenValue.contains("=>"))
		{
			remove_implication(tokenValue,tokenType);
			//classify_tokens_based_on_type(tokenValue,tokenType);
		}
		combine_tokens(tokenValue,statement);

		tokenType.clear();
		tokenValue.clear();
		return statement;
	}

	public static StringBuffer remove_bi_conditional(StringBuffer statement) 
	{
		LinkedList<String> tokenValue=new LinkedList<String>();
		LinkedList<String> tokenType=new LinkedList<String>();

		split_into_tokens(tokenValue,statement);
		//classify_tokens_based_on_type(tokenValue,tokenType);
		while(tokenValue.contains("<=>"))
		{
			remove_double_implication(tokenValue,tokenType);
			//classify_tokens_based_on_type(tokenValue,tokenType);
		}
		combine_tokens(tokenValue,statement);

		tokenType.clear();
		tokenValue.clear();
		return statement;
	}

	public static void divide_into_clauses(LinkedList<String> storage) 
	{
		boolean divide=true;
		for(int i=0;i<storage.size();i++)
		{
			divide=true;
			while(divide)
				divide=divide_KB_into_clauses(storage, i);
		}
		return;
	}

	public static StringBuffer expand_NOT(StringBuffer statement)
	{
		LinkedList<String> tokenValue=new LinkedList<String>();
		LinkedList<String> tokenType =new LinkedList<String>();
		StringBuffer check_op1=new StringBuffer();
		int currentIndexNOT,prevIndexNOT;
		boolean distributed=false;

		split_into_tokens(tokenValue, statement);
		classify_tokens_based_on_type(tokenValue, tokenType);
		prevIndexNOT=0;
		while(true)
		{
			currentIndexNOT=-1;
			for (int i=prevIndexNOT;i<tokenValue.size();i++)
			{
				if(tokenValue.get(i).equals("NOT"))
				{
					currentIndexNOT=i;
					break;
				}
			}
			if(currentIndexNOT==-1)
				break;
			check_op1.delete(0,check_op1.length());
			get_operand(tokenValue, currentIndexNOT+1, check_op1);
			distributed=check_if_NOT_already_distributed(check_op1);
			if(!distributed)
			{
				distribute_NOT(tokenValue,tokenType, currentIndexNOT);
				combine_tokens(tokenValue, statement);
			}
			prevIndexNOT=currentIndexNOT+1;
		}

		tokenType.clear();
		tokenValue.clear();
		return statement;
	}

	/*public static void convert_alpha_to_CNF(String alpha) 
	{
		return;
	}

	/*public static void remove_and_from_clauses(LinkedList<String> KB, int index) 
	{
		boolean divide=true;
		for(int i=index;i<KB.size();i++)
		{
			while(divide)
				divide=divide_KB_into_clauses(KB, i);
		}
		return;
	}*/

	public static boolean divide_KB_into_clauses(LinkedList<String> KB, int index) 
	{
		boolean divide=false;
		StringBuffer line=new StringBuffer(KB.get(index));
		LinkedList<String> tokens=new LinkedList<String>();
		StringBuffer op1=new StringBuffer();
		StringBuffer op2=new StringBuffer();
		int end=0,i=0,count=0,op1_end_index=0;//op2_end_index=0;

		split_into_tokens(tokens, line);
		if((end=(tokens.indexOf("AND")))!=-1)
		{
			for(i=0;i<end;i++)
			{
				if(tokens.get(i).equals("("))
				{
					count++;
				}
				else if(tokens.get(i).equals(")"))
				{
					count--;
				}		
			}
			if(count==1)
			{
				op1_end_index=get_operand(tokens, end+1, op1);
				get_operand(tokens, op1_end_index+1, op2);
				KB.remove(index);
				if (!KB.contains(op1.toString()))
					KB.add(index,op1.toString());
				if (!KB.contains(op2.toString()))
					KB.add(index+1,op2.toString());
				divide=true;
			}
		}

		tokens.clear();
		return divide;
	}

	public static StringBuffer remove_unwanted_paranthesis(StringBuffer line)
	{
		LinkedList<String> tokens=new LinkedList<String>();
		int i=0,start=0,end=0;
		boolean unwanted=true;

		while(unwanted)
		{
			//System.out.println("line:"+line);
			tokens.clear();
			split_into_tokens(tokens, line);
			//System.out.println("before:"+line);
			for(i=0;i<tokens.size()-1;i++)
			{
				if((tokens.get(i).equals("("))&&(tokens.get(i+1).equals("(")))
				{
					start=i;
					end=find_matching_end(tokens,i);
					unwanted=true;
					break;
				}
				else
					unwanted=false;
			}
			if(unwanted)
			{
				tokens.remove(start);
				tokens.remove(end-1);
			}
			//line.delete(0, tokens.size());
			combine_tokens(tokens, line);
			//for(int j=0;j<tokens.size();j++)
			//System.out.println("token j:"+tokens.get(j));
			//System.out.println("line:"+line);
		}
		tokens.clear();
		return line;
	}

	public static int find_matching_end(LinkedList<String> tokens, int index)
	{
		int count=0,i=0;
		for (i=index;i<tokens.size();i++)
		{
			if(tokens.get(i).equals("("))
				count++;
			if(tokens.get(i).equals(")"))
			{
				count--;
				if(count==0)
					break;
			}
		}
		return i;
	}

	public static boolean check_if_NOT_already_distributed( StringBuffer statement) 
	{
		LinkedList<String> op_token_value=new LinkedList<String>();
		LinkedList<String> op_token_type=new LinkedList<String>();
		String first,second,third;
		boolean distributed=false;

		split_into_tokens(op_token_value,statement);
		classify_tokens_based_on_type(op_token_value, op_token_type);

		first=op_token_type.get(0);
		//System.out.println(first);
		if(first.equals("LIT"))
			distributed=true;
		if((first.equals("(")))
		{
			second=op_token_type.get(1);
			//System.out.println(second);
			third=op_token_type.get(2);
			//System.out.println(third);
			if((second.equals("LIT"))&&(third.equals(")")))
				distributed=true;
		}

		op_token_value.clear();
		op_token_type.clear();
		return distributed;
	}

	public static void classify_tokens_based_on_type(LinkedList<String> tokenValue,LinkedList<String> tokenType) 
	{
		tokenType.clear();
		for(int i=0;i<tokenValue.size();i++)
		{
			if(tokenValue.get(i).equals("("))
				tokenType.add("(");
			else if(tokenValue.get(i).equals(")"))
				tokenType.add(")");
			else if(tokenValue.get(i).matches("NOT|OR|AND"))
				tokenType.add("OPR");
			else if(tokenValue.get(i).matches("[a-zA-Z]+"))
				tokenType.add("LIT");
			/*else
			{
				System.out.println("culprit:"+tokenValue.get(i));
				tokenType.add("ZZZ");
			}
			System.out.println("tokenvalue i:"+i+" "+tokenValue.get(i));
			System.out.println("tokentype i:"+i+" "+tokenType.get(i));*/
		}
		return;
	}

	public static void combine_tokens(LinkedList<String> tokenValue,StringBuffer statement) 
	{
		StringBuffer line=new StringBuffer();
		for(int i=0;i<tokenValue.size();i++)
			line.append(tokenValue.get(i)+" ");
		statement.delete(0,statement.length());
		statement.append(line);
		return;
	}

	public static void split_into_tokens(LinkedList<String> tokenValue, StringBuffer statement)
	{
		String data[]=new String[200];
		tokenValue.clear();
		data=statement.toString().split("[ \\t\\n\\r]+");
		for(int i=0;i<data.length;i++)
			tokenValue.add(data[i]);
		return;
	}


	public static int get_operand(LinkedList<String> tokenValue, int index, StringBuffer op)
	{
		int i,count;

		i=index;
		if(tokenValue.get(i).equals("("))
		{
			count=0;
			while(i<tokenValue.size())
			{
				op.append(tokenValue.get(i));
				if(tokenValue.get(i).equals("("))
				{
					count++;
				}
				if(tokenValue.get(i).equals(")"))
				{
					count--;
					if(count==0)
						break;
				}
				op.append(" ");
				i++;
			}
		}
		else
		{
			op.append(tokenValue.get(i));
		}
		return i;
	}

	public static void remove_double_implication(LinkedList<String> tokenValue,LinkedList<String> tokenType)
	{
		StringBuffer op1=new StringBuffer();
		StringBuffer op2=new StringBuffer();
		StringBuffer op3=new StringBuffer();
		StringBuffer op4=new StringBuffer();
		String data[]=new String[100];
		String result;
		int index,op1_end_index,op2_end_index,i;

		index=tokenValue.indexOf("<=>");
		op1_end_index=get_operand(tokenValue,index+1,op1);
		op2_end_index=get_operand(tokenValue,op1_end_index+1,op2);
		op3.append(op1);
		op4.append(op2);
		delete_tokens(tokenValue,tokenType,index,op2_end_index);
		op1.insert(0,"AND  ( => ");
		op2.append(" ) ( => "+op4+" "+op3+" )");
		result=new String(op1.toString()+" "+op2.toString());
		data=result.split("[ \\t\\n\\r]+");
		for(i=0;i<data.length;i++)
			tokenValue.add(index+i,data[i]);

		return;
	}

	public static void remove_implication(LinkedList<String> tokenValue,LinkedList<String> tokenType)
	{	
		StringBuffer op1=new StringBuffer();
		StringBuffer op2=new StringBuffer();
		String data[]=new String[200];
		String result;
		int index,op1_end_index,op2_end_index,i;

		index=tokenValue.indexOf("=>");
		op1_end_index=get_operand(tokenValue,index+1,op1);
		//System.out.println("op1:"+op1);
		op2_end_index=get_operand(tokenValue,op1_end_index+1,op2);
		//System.out.println("op2:"+op2+" index: "+op2_end_index);
		delete_tokens(tokenValue,tokenType,index,op2_end_index);
		op1.insert(0,"OR ( NOT ");
		op1.append(" )");
		result=new String(op1.toString()+" "+op2.toString());
		data=result.split("[ \\t\\n\\r]+");
		for(i=0;i<data.length;i++)
			tokenValue.add(index+i,data[i]);
		return;
	}


	public static void delete_tokens(LinkedList<String> tokenValue,LinkedList<String> tokenType,int start, int end) 
	{
		StringBuffer statement=new StringBuffer();
		combine_tokens(tokenValue, statement);
		//classify_tokens_based_on_type(tokenValue, tokenType);
		int i=start;
		//System.out.println("state:"+statement);
		while(i<=end)
		{
			tokenValue.remove(i);
			//tokenType.remove(i);
			end=end-1;
		}
		return;
	}


	public static void distribute_NOT(LinkedList<String> tokenValue, LinkedList<String> tokenType, int index)
	{
		StringBuffer op1=new StringBuffer();
		String current_token,first,second;
		LinkedList<String> op1_tokenValue=new LinkedList<String>();
		LinkedList<String> op1_tokenType=new LinkedList<String>();
		int op1_end_index,i=1;

		int op1_not_and_index,op2_not_and_index;
		StringBuffer op1_not_and=new StringBuffer();
		StringBuffer op2_not_and=new StringBuffer();

		int op1_not_or_index,op2_not_or_index;
		StringBuffer op1_not_or=new StringBuffer();
		StringBuffer op2_not_or=new StringBuffer();

		/*int op1_not_index;
		StringBuffer op1_not=new StringBuffer();*/

		op1_end_index=get_operand(tokenValue,index+1,op1);
		delete_tokens(tokenValue, tokenType, index, op1_end_index);

		split_into_tokens(op1_tokenValue, op1);
		classify_tokens_based_on_type(op1_tokenValue, op1_tokenType);
		first=op1_tokenType.get(0);
		if(first.equals("("))
		{
			second=op1_tokenType.get(1);
			if(second.equals("OPR"))
			{
				i=1;
				current_token=op1_tokenValue.get(i);
				if(current_token.equals("NOT"))
				{
					op1_tokenValue.remove(i);
					op1_tokenType.remove(i);

					op1_tokenValue.remove(op1_tokenValue.size()-1);
					op1_tokenType.remove(op1_tokenType.size()-1);

					op1_tokenValue.remove(0);
					op1_tokenType.remove(0);
				}
				if(current_token.equals("AND"))
				{
					//System.out.println("before remove:"+op1_tokenValue.get(i));
					op1_tokenValue.remove(i);
					op1_tokenValue.add(i,"OR");
					StringBuffer and_operand=new StringBuffer();
					//System.out.println("i+1:"+op1_tokenValue.get(i+1));

					/*op1_not_or_index=get_operand(op1_tokenValue,i+1,op1_not_or);
					System.out.println("check1:"+op1_not_or);
					System.out.println("not or index:"+op1_tokenValue.get(op1_not_or_index));
					op1_tokenValue.add(i+1,"NOT");
					op1_tokenType.add(i+1,"OPR");
					//op1_tokenValue.add(i+2,"(");
					//op1_tokenType.add(i+2,"(");

					op2_not_or_index=get_operand(op1_tokenValue,op1_not_or_index+2,op2_not_or);
					System.out.println("check2:"+op2_not_or);
					op1_tokenValue.add(op1_not_or_index+2, "NOT");
					op1_tokenType.add(op1_not_or_index+2, "OPR");*/

					op1_not_and_index=get_operand(op1_tokenValue,i+1,op1_not_and);
					op1_not_and.insert(0, "( NOT ");
					op1_not_and.append(" )");

					op2_not_and_index=get_operand(op1_tokenValue,op1_not_and_index+1,op2_not_and);
					op2_not_and.insert(0, "( NOT ");
					op2_not_and.append(" )");

					and_operand.append(op1_not_and+" "+op2_not_and);
					//System.out.println("and operand:"+and_operand);
					LinkedList<String> tokens=new LinkedList<String>();
					//System.out.println("i+1:"+op1_tokenValue.get(i+1));
					delete_tokens(op1_tokenValue, op1_tokenType, i+1, op2_not_and_index);
					split_into_tokens(tokens, and_operand);
					/*for(int j=0;j<tokens.size();j++)
					{

						System.out.println("index:"+j+"tokens:"+tokens.get(j));
					}
					/*System.out.println("i+1:"+op1_tokenValue.get(i+1));
					System.out.println("index:0 op1_tokenValue:"+op1_tokenValue.get(0));
					System.out.println("index:1 op1_tokenValue:"+op1_tokenValue.get(1));*/
					for(int j=0;j<tokens.size();j++)
					{
						//int tmp=i+1+j;
						op1_tokenValue.add(i+1+j, tokens.get(j));
						//System.out.println("index:"+tmp+"op1_tokenValue:"+op1_tokenValue.get(tmp));
					}
					//i=op2_not_or_index+4;


				}

				if(current_token.equals("OR"))
				{
					StringBuffer or_operand=new StringBuffer();
					LinkedList<String> tokens=new LinkedList<String>();

					op1_tokenValue.remove(i);
					op1_tokenValue.add(i,"AND");

					op1_not_or_index=get_operand(op1_tokenValue,i+1,op1_not_or);
					op1_not_or.insert(0, "( NOT ");
					op1_not_or.append(" )");

					op2_not_or_index=get_operand(op1_tokenValue,op1_not_or_index+1,op2_not_or);
					op2_not_or.insert(0, "( NOT ");
					op2_not_or.append(" )");

					or_operand.append(op1_not_or+" "+op2_not_or);

					delete_tokens(op1_tokenValue, op1_tokenType, i+1, op2_not_or_index);
					split_into_tokens(tokens, or_operand);
					for(int j=0;j<tokens.size();j++)
					{
						//int tmp=i+1+j;
						op1_tokenValue.add(i+1+j, tokens.get(j));
					}
				}
				classify_tokens_based_on_type(op1_tokenValue, op1_tokenType);
				join_tokenlist(tokenValue,tokenType,op1_tokenValue,op1_tokenType,index); 
			}
		}

		op1_tokenType.clear();
		op1_tokenValue.clear();
		return ;
	}

	public static void join_tokenlist(LinkedList<String> tokenValue,LinkedList<String> tokenType, LinkedList<String> toadd_tokenValue,
			LinkedList<String> toadd_tokenType, int index) 
	{
		for(int i=0;i<toadd_tokenValue.size();i++)
		{
			tokenValue.add(index+i, toadd_tokenValue.get(i));
			tokenType.add(index+i, toadd_tokenType.get(i));
		}
		return;
	}


	public static StringBuffer distribute_OR(StringBuffer statement)
	{
		LinkedList<String> tokens=new LinkedList<String>();
		LinkedList<String> outer_op1_tokens=new LinkedList<String>();
		LinkedList<String> outer_op2_tokens=new LinkedList<String>();


		StringBuffer outer_op1=new StringBuffer();
		StringBuffer outer_op2=new StringBuffer();
		StringBuffer alpha=new StringBuffer();
		StringBuffer beta=new StringBuffer();
		StringBuffer gamma=new StringBuffer();
		StringBuffer result=new StringBuffer();
		StringBuffer op1_result=new StringBuffer();
		StringBuffer op2_result=new StringBuffer();


		StringBuffer outer_operator=new StringBuffer();
		StringBuffer inner_op1_operator=new StringBuffer();
		StringBuffer inner_op2_operator=new StringBuffer();
		int outer_op1_end_index=0,inner_op1_end_index=0;//inner_op2_end_index=0,outer_op2_end_index=0;

		//System.out.println("statement:"+statement);
		split_into_tokens(tokens, statement);
		//if(tokens.size()>0)
		//{
		outer_operator.delete(0, outer_operator.length());
		outer_operator.append(get_operator(tokens,0));
		//System.out.println("outer operator:"+outer_operator);
		result.delete(0, result.length());
		result.append(statement);
		if(outer_operator.toString().equals("OR"))
		{
			//System.out.println("enter");
			if(tokens.contains("AND"))
			{
				outer_op1_end_index=get_operand(tokens, 2, outer_op1);
				get_operand(tokens, outer_op1_end_index+1, outer_op2);
				//outer_op2_end_index=get_operand(tokens, outer_op1_end_index+1, outer_op2);
				//System.out.println("outer_op1:"+outer_op1);
				//System.out.println("outer_op2:"+outer_op2);

				split_into_tokens(outer_op1_tokens,outer_op1);
				split_into_tokens(outer_op2_tokens,outer_op2);

				inner_op1_operator.delete(0, inner_op1_operator.length());
				inner_op1_operator.append(get_operator(outer_op1_tokens,0));

				inner_op2_operator.delete(0, inner_op2_operator.length());
				inner_op2_operator.append(get_operator(outer_op2_tokens,0));
				//System.out.println("inner op1 operator:"+inner_op1_operator);
				//System.out.println("inner op2 operator:"+inner_op2_operator);

				if(inner_op1_operator.toString().equals("AND"))
				{
					beta.delete(0, beta.length());
					gamma.delete(0, gamma.length());
					alpha.delete(0, alpha.length());
					result.delete(0, result.length());
					inner_op1_end_index=get_operand(outer_op1_tokens, 2, beta);
					get_operand(outer_op1_tokens, inner_op1_end_index+1, gamma);
					//inner_op2_end_index=get_operand(outer_op1_tokens, inner_op1_end_index+1, gamma);
					alpha.append(outer_op2);
					result.append("( AND ( OR "+beta+" "+alpha+" ) ( OR "+gamma+" "+alpha+" ) )");
					//System.out.println("result1:"+result);
				}
				else if(inner_op2_operator.toString().equals("AND"))
				{
					beta.delete(0, beta.length());
					gamma.delete(0, gamma.length());
					alpha.delete(0, alpha.length());
					result.delete(0, result.length());
					inner_op1_end_index=get_operand(outer_op2_tokens, 2, beta);
					get_operand(outer_op2_tokens, inner_op1_end_index+1, gamma);
					//inner_op2_end_index=get_operand(outer_op2_tokens, inner_op1_end_index+1, gamma);
					alpha.append(outer_op1);
					result.append("( AND ( OR "+alpha+" "+beta+" ) ( OR "+alpha+" "+gamma+" ) )");
					//System.out.println("result2:"+result);
				}
				else
				{
					op1_result.delete(0, op1_result.length());
					op2_result.delete(0, op2_result.length());

					//System.out.println("outer_op1:"+outer_op1);
					op1_result.append(distribute_OR(outer_op1));
					//System.out.println("op1 result:"+op1_result);

					//System.out.println("outer_op2:"+outer_op2);
					op2_result.append(distribute_OR(outer_op2));
					//System.out.println("op2 result:"+op2_result);

					result.delete(0, result.length());
					result.append("( "+outer_operator+" "+op1_result+" "+op2_result+" )");
					//System.out.println("result3:"+result);
					//distribute_OR(result);
				}
			}
		}
		//}
		//System.out.println("exit");

		tokens.clear();
		outer_op1_tokens.clear();
		outer_op2_tokens.clear();
		return result;
	}

	public static String get_operator(LinkedList<String> tokens, int index)
	{
		StringBuffer result=new StringBuffer();
		for(int i=index;i<tokens.size();i++)
		{
			if(tokens.get(i).equals("NOT"))
			{
				result.append("NOT");
				break;
			}
			else if(tokens.get(i).equals("AND"))
			{
				result.append("AND");
				break;
			}
			else if(tokens.get(i).equals("OR"))
			{
				result.append("OR");
				break;
			}

		}
		return result.toString();
	}



}
